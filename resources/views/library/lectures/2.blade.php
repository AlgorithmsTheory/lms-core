@extends('templates.base')
@section('head')
		<title>Лекция 2</title>

		<!-- BEGIN META -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="keywords" content="your,keywords">
		<meta name="description" content="Short explanation about this website">
		<!-- END META -->

		<!-- BEGIN STYLESHEETS -->
        {!! HTML::style('css/bootstrap.css') !!}
        {!! HTML::style('css/materialadmin.css') !!}
        {!! HTML::style('css/font-awesome.min.css') !!}
        {!! HTML::style('css/material-design-iconic-font.min.css') !!}
        <!-- END STYLESHEETS -->

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
        {!! HTML::script('js/libs/utils/html5shiv.js') !!}
        {!! HTML::script('js/libs/utils/respond.min.js') !!}
        <![endif]-->


@stop
@section('content')


				<!-- BEGIN BLANK SECTION -->
				<section>
					<div class="section-header">
						<ol class="breadcrumb">
                            <li>{!! HTML::linkRoute('home', 'Главная') !!}</li>
                            <li>{!! HTML::linkRoute('library_index', 'Библиотека') !!}</li>
							<li class="active">Лекция 2. Модификации машин Тьюринга</li>
						</ol>
					</div><!--end .section-header -->
					<div class="section-body">
					</div><!--end .section-body -->
				</section>
	<div class="card card-tiles style-default-light" style="margin-left:2%; margin-right:2%">
	<article class="style-default-bright">
		<div class="card-body"> 
		<article style="margin-left:10%; margin-right:10%; text-align: justify">
			
<p><strong>Многоленточные машины Тьюринга</strong></p>

<p>Для некоторых задач составление алгоритмов работы для одноленточной машины Тьюринга представляет значительные трудности, связанные с необходимостью где-то хранить результаты промежуточных вычислений, или производить посимвольное сравнение нескольких групп элементов. В некоторых случаях наличие дополнительной (рабочей) ленты или размещение входных слов на нескольких лентах одновременно позволяет получить более лаконичное решение.</p>

<p>Однако, как это ни покажется парадоксальным, вычислительная способность таких машин совершенно не превосходит их одноленточных аналогов.&nbsp; Иными словами, задачи, которые можно решить на многоленточной машине с произвольным количеством лент, всегда решаются и при помощи одноленточной машины.</p>

<p>Многоленточная машина для каждой ленты в общем случае может иметь свой внешний алфавит. Ленты в машине движутся независимо друг от друга. Однако состояние для всех лент машины единое, по сути, это состояние управляющего механизма. Ранее, при рассмотрении одноленточных машин, было принято считать, что лента неподвижна, а управляющая головка перемещается в заданном направлении. Но для рассмотрения многоленточных машин это может оказаться не вполне удобно, потому что ленты являются независимыми, а наглядно представить перемещение единого&nbsp; управляющего механизма по разным направлениям весьма проблематично.</p>

<p><em>Первое решение</em> проблемы: считаем, что управляющий механизм неподвижен, а ленты могут свободно перемещаться вправо, влево или оставаться на месте независимо друг от друга. Тогда при составлении программы машины Тьюринга при указании направления движения следует придерживаться обратной записи: если обычно управляющий механизм на первом шаге двигался вправо, то теперь ленты машины начинают движение влево относительно неподвижного механизма.</p>

<p><em>Второе решение</em> проблемы: если подобное &laquo;зеркальное&raquo; представление не кажется удобным, можно пойти по классическому пути. Допустим, что управляющий механизм подсоединен к набору окошек, в которые обозреваются непосредственно символы на лентах. Тогда считаем,&nbsp; что эти окошки на каждой из лент движутся независимо друг от друга. Виртуально этот процесс становится хоть как то представимым, если вообразить наличие неких пружинок, которые соединяют между собой окошки и привязывают их к единому управляющему механизму. В этом случае нотация для записи команд в программе машины Тьюринга остается неизменной.</p>

<p>Далее в книге будет использоваться классический способ (двигается управляющий механизм, ленты неподвижны) и принят следующий формат записи:</p>

<p>S<sub>i</sub>{a,b,c}&rarr;{a&#39;,b&#39;,c&#39;}{R,L,H}S<sub>j</sub>.</p>

<p>&nbsp;</p>

<p style="margin-left:36.0pt"><em><a name="1">Машина <strong>В</strong> <strong>эквивалентна</strong> машине <strong>А</strong>, если в соответствующие такты их работы лента машины <strong>В</strong> содержит всю информацию о ленте машины <strong>А</strong>. </em></a></p>
<p>&nbsp;</p>

<p>Одна из машин может работать гораздо медленнее другой, т.к. каждый такт она моделирует несколькими тактами, поэтому мы говорим о соответствующих тактах. Если в конце концов <strong><em>А</em></strong> остановится, то <strong><em>В</em></strong> тоже остановится и к этому моменту будет содержать всю информацию о ленте машины <strong><em>А</em></strong>.</p>

<p>&nbsp;</p>

<p><strong><u>Теорема.</u></strong><strong> Всякая </strong><strong>k</strong><strong>-ленточная машина Тьюринга М может быть преобразована в эквивалентную машину М* с одной лентой. </strong></p>

<p style="margin-left:9pt">&nbsp;</p>

<p style="margin-left:27.6pt"><strong><u>Доказательство</u></strong></p>

<p>Пусть есть k -ленточная машина М и одноленточная машина М*. Запишем содержимое лент машины М в виде матрицы с 2k строками и бесконечным числом столбцов. В матрице нечетные строки (1, 3, 5 и т.д. до 2k-1 -ой) занимают непосредственно ленты машины М,&nbsp; а четные (2, 4, 6, &hellip;,&nbsp; 2k-ая) являются служебными. На каждой из служебных строк записан только один символ &laquo;*&raquo; и его расположение указывает на положение смотрового окошка управляющего механизма на соответствующей ленте. Например, на 2-ой строке специальный символ * стоит в той клетке, которая находится непосредственно под клеткой, обозреваемой управляющей головкой на первой ленте.</p>

<p><center>{!! HTML::image('img/library/Pic/2.1.jpg', 'a picture', array('style' => 'height:277px; width:630px')) !!}</center></p>

<p><center>Рис.1. Матрица, содержащая информацию о лентах машины М<span style="color:#FF0000">.</span></center></p>

<p>&nbsp;</p>

<p>Построим ленту машины М*. Для этого содержимое матрицы перенесем на ленту одноленточной машины по столбцам: сначала первый столбец, затем второй и т.д. Одна гиперклетка (набор клеток) машины М* равна целому столбцу в таблице.</p>

<p>&nbsp;</p>

<p><center>{!! HTML::image('img/library/Pic/2.2.jpg', 'a picture', array('style' => 'height:38px; width:543px')) !!}</center></p>

<p>&nbsp;</p>

<p><center>Рис.2. Лента машины М*.</center></p>

<p>&nbsp;</p>

<p>В этом случае работа машины М* будет повторять работу машины М с тем отличием, что для воспроизведения команды машины М потребуется набор передвижений с целью определения истинной конфигурации. Для этого на ленте машины М* поочередно отыскиваются все символы * и считываются находящиеся слева от них символы внешнего алфавита соответствующих лент. Т.о. определяется текущая конфигурация машины М. Далее по программе машины М определяются необходимые действия и они моделируются исходя из формата записи машины М*. Например, перемещение управляющего механизма вправо на какой-нибудь из лент имитируется переносом соответствующего символа * на 2k клеток вправо.</p>

<p>Здесь стоит заметить, что в общем случае,&nbsp; не вполне очевидно, как машина М* будет опознавать на какой из лент находится символ, расположенный левее очередной обнаруженной *. В случае, если алфавиты на всех k лентах различны, это трудностей не составляет и будет учтено при составлении программы соответствующим подбором возможных конфигураций. В случае если алфавиты на некоторых или всех лентах совпадают или имеют непустое пересечение, возникает потребность в различных символах, например r<sub>1</sub>, r<sub>2</sub>, r<sub>3</sub> и т.д. вместо предложенного выше единого символа *.</p>

<p>Таким образом показано, что k-ленточная машина Тьюринга может быть преобразована в эквивалентную ей одноленточную машину Тьюринга, <strong>Q.E.D.</strong></p>

<p>&nbsp;</p>

<p>Здесь и далее при завершении доказательства теорем будет записано общепринятое сокращенное обозначение окончания этого процесса, <strong>Q.E.D.</strong></p>

<p>&nbsp;</p>

<p style="margin-left:36.0pt"><strong><em>Q.E.D. (</em></strong><em>аббревиатура от лат.&nbsp;</em><strong><em>quod erat demonstrandum</em></strong> <em>&mdash; &laquo;что доказывалось&raquo;, &laquo;что и требовалось доказать&raquo;): латинское выражение, обозначающее завершение доказательства теоремы.</em></p>

<h2 style="margin-left:15.0pt">Специальные машины Тьюринга</h2>


<p><strong>Самоанализирующие машины Тьюринга </strong></p>

<p>Разделим знаки таблицы машины Тьюринга на ленточные и служебные:</p>

<ul>
	<li>ленточные знаки &ndash; это символы внешнего алфавита,</li>
	<li>служебные знаки &ndash; это символы внутреннего алфавита (состояния машины), разделитель (он нужен, если таблица записывается в 1 строчку), знаки движения.</li>
</ul>

<p>&nbsp;</p>

<p style="margin-left:36.0pt"><strong><em><a name="selfanalysis">Самоанализирующие машины</a></em></strong><em> - это машины, в которых все служебные символы как-либо изображаются ленточными символами.</em></p>

<p>&nbsp;</p>

<p>Приведем пример самоанализирующей машины М. Допустим:</p>

<p>А &ndash; знак единственного внутреннего состояния</p>

<p>R &ndash; знак движения вправо</p>

<p>H &ndash; знак остановки</p>

<p>Х &ndash; табличный разделитель команд</p>

<p>Тогда введем ленточные образы этих знаков:</p>

<p>А &ndash; &alpha;</p>

<p>R &ndash; &rho;</p>

<p>H &ndash;&delta;</p>

<p>Х &ndash; &xi;&nbsp;</p>

<p>Можно предложить нарочито упрощенный пример программы машины М.</p>

<p>A &alpha;&nbsp; &rarr; &xi; R A //если машина находится в состоянии А (ленточный образ &alpha;), то на это место ставится образ разделителя команд X (&xi;).</p>

<p>A &xi;&nbsp; &rarr; &xi; R A&nbsp; //переход через ленточный образ разделителя команд Х (&xi;).</p>

<p>A &rho;&nbsp; &rarr; &delta; H A&nbsp; //если машине предписано двигаться вправо, она меняет ленточный образ символа R (&rho;) на ленточный образ символа Н (&delta;) и останавливается.</p>

<p>Посмотрим, как будет проистекать самоанализ машины&nbsp; М.</p>

<p>Как уже упоминалось, образы служебных знаков могут совпадать с самими служебными знаками, но в нашем описании рабочего процесса мы должны их различать.</p>

<p>Код программы машины выглядит так:</p>

<p>&nbsp; A &alpha;&nbsp; &xi; R A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Х</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A &xi;&nbsp; &xi;&nbsp; R A&nbsp;&nbsp; &nbsp;&nbsp;<strong>X</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A &rho; &delta; H A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>X</strong></p>

<p>Тогда на ленте запишем этот же&nbsp; код, заменив знаки ленточными образами (пробелы поставлены для повышения читаемости, на ленте символы реально записаны друг за другом). Машина находится в состоянии А, ее положение на ленте показано графически.</p>

<p>&nbsp;</p>

<p><center>{!! HTML::image('img/library/Pic/2.3.JPG', 'a picture', array('style' => 'height:400px; width:543px')) !!}</center></p>


<p>Если в понятие машины Тьюринга включить условие, что при появлении конфигураций, не предусмотренных в таблице машины, она останавливается, то из любой машины Тьюринга легко получить самоанализирующую машину, включив в ее ленточный алфавит все служебные знаки, ранее в нем отсутствующие. Если в первоначальном алфавите их вовсе не было, то новая машина при самоанализе&nbsp; сразу остановится (т.н. тривиальный самоанализ).</p>

<p>&nbsp;</p>

<p><strong>Универсальные машины</strong></p>

<p>&nbsp;Тьюринг показал возможность построения определённой вычислительной машины U, универсальной в том смысле, что на U можно выполнить любое вычисление.</p>

<p>&nbsp;</p>

<p style="margin-left:36.0pt"><strong><em><a name="universal">Универсальная машина</a></em></strong><em> &ndash; машина Тьюринга, обладающая способностью путём подходящего кодирования выполнить любое вычисление.</em></p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp; Однако к этому, несомненно, надо присоединить то условие, что кодирование должно быть в некотором смысле простым. В самом деле, нет особой выгоды считать универсальной машину Тьюринга, у которой кодирование, по существу, требует работы другой универсальной машины. Отсюда возникает задача явного определения <strong><em>универсальной машины Тьюринга</em>.</strong> Далее универсальная машина Тьюринга будет сокращенно именоваться <strong><em>УМТ</em></strong>.</p>

<p>На ленте УМТ записывается кодовая последовательность, характеризующая данную МТ (программа произвольной МТ и входное слово), и УМТ должна читать эту кодовую последовательность и выполнять всю работу той машины, программа которой записана на её ленте.&nbsp; УМТ должна печатать знаки в таком же коде, как и в таблице. Соответственно для такой машины необходимы входные слова, записанные по какому-то методу (единообразный метод записи программ и входных слов). Поскольку число возможных знаков &ndash; бесконечно, а у машины конечный алфавит, поэтому всё (и состояния, и символы) кодируется последовательностью других знаков (чисел).</p>

<p>Пусть машина <em>А </em>&nbsp;имеет <em>m</em> символов <em>a<sub>j</sub></em>&nbsp; и <em>n</em> внутренних состояний <em>S<sub>i</sub></em> . Закодируем знаки, используемые при написании программы работы такой машины следующим образом.</p>

<p><em>a</em><em><sub>j </sub></em><em>= 1&hellip;1&nbsp; </em>(<em>a<sub>1</sub>=1, a<sub>2</sub>=11, a<sub>3</sub>=111 </em>и т.д.)</p>

<p><em>S<sub>i </sub></em><em>=&nbsp; 2&hellip;2&nbsp; </em>(<em>S<sub>1</sub>=2, S<sub>2</sub>=22, S<sub>3</sub>=222 </em>и т.д.)</p>

<p><em>R</em><em> = 3</em></p>

<p><em>L</em> <em>= 33</em></p>

<p><em>H</em> <em>= 333 </em></p>

<p>В этом случае всю программу работы машины можно записать неким числом, причем возможны два варианта записи:</p>

<p>1. С разделителем команд, допустим Х, которые можно закодировать числом 4. В этом случае классическая запись <em>S<sub>old</sub></em> <em>a<sub>old</sub></em><em><sub>&rarr;</sub></em> <em>a<sub>new</sub></em> <em>R</em> <em>S<sub>new</sub></em><em>,</em></p>

<p>2. Без разделителя команд. В этом случае команды следует писать в формате <em>a<sub>old</sub></em> <em>S<sub>old</sub></em> <em>a<sub>new</sub></em> <em>R</em> <em>S<sub>new</sub></em><em>, </em>тогда две команды, записанные непосредственно друг за другом, будут явно различаться элементарным анализатором.</p>

<p>&nbsp;</p>

<p>Возьмем в качестве примера&nbsp; машину Тьюринга, которая на пустой ленте бесконечно много раз печатает последовательность <em>001</em>. Сразу оговоримся, что из соображений удобства формат записи будет следующим <em>aS<sub>i</sub></em> <em>&rarr; </em><em>a</em><em>&#39;{</em><em>R</em><em>,</em><em>L</em><em>,</em><em>H</em><em>}</em><em>S<sub>j</sub></em><em>.</em> При такой записи обозначение символа указывается ранее обозначения состояния. Цель данной перестановки довольно банальная: избежать наличия лишнего разделителя.</p>

<p>Программа такой машины выглядит следующим образом (<em>&lambda;</em>-пустой знак):</p>

<p><em>&lambda;</em> <em>A</em><em> 0 </em><em>R</em> <em>B</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p><em>&lambda;</em> <em>B</em><em> 0 </em><em>R</em> <em>C</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>

<p><em>&lambda;</em> <em>C</em><em> 1 </em><em>R</em> <em>A</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>Закодируем символы и состояния:</p>

<p><em>&lambda;</em><em>=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em><em>A</em><em>=2</em></p>

<p><em>0=11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em><em>B</em><em>=22</em></p>

<p><em>1=111&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em><em>C</em><em>=222</em></p>

<p>Тогда запись программы машины будет выглядеть так (пробелы поставлены для повышения читаемости, в реальности их нет):</p>

<p><em>1 2 11 3 22&nbsp;&nbsp;&nbsp;&nbsp; 1 22 11 3 222&nbsp;&nbsp;&nbsp; 1 222 111 3 2</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>Т.о. каждая МТ представлена числом &ndash; это дескриптивное (описательное) число машины. Вместе с тем оно является кодом для входного слова. Т.о. решается проблема унификации записи программы машины Тьюринга и входного слова на её ленте.</p>

<p>Несмотря на это построение реально работающей универсальной машины Тьюринга представляет собой довольно сложный процесс.</p>

<p>&nbsp;</p>

<p><strong>Пример построения универсальной машины Тьюринга</strong></p>

<p>По сути УМТ является программируемой машиной Тьюринга, с тем отличием, что собственно программа не является внутренним элементом функциональной схемы, которая управляет считывающей головкой, а просто записана на ленте. Т.о. одна и та же машина получает способность выполнять любую задачу (разумеется, если для этой задачи существует алгоритм решения).</p>

<p>&nbsp;Рассмотрим УМТ. Ее алфавит ограничен символами 1,2,3,4. Тогда, если &nbsp;цифру 5 использовать для разделения описания машины и описания входного слова, лента выглядит следующим образом (рис.3.).</p>

<p><center>{!! HTML::image('img/library/Pic/2.4.jpg', 'a picture', array('style' => 'height:58px; width:600px')) !!}</center></p>
 
<p><center>Рис.3. Схематичное изображение ленты УМТ.</center></p>

<p>&nbsp;</p>

<p>На рис.3. <em>dT</em> &ndash; описание машины, <em>dW</em> &ndash; описание входного слова, в котором каждый символ слова <em>a<sub>i</sub></em> записан в виде наборов по несколько <em>1</em>, разделенных специальным символом <em>4</em> (разделитель).</p>

<p>Описание машины &ndash; слово, разбитое на команды. УМТ читает описание данной машины, а затем перерабатывает входное слово так, как бы это сделала конкретная МТ. УМТ имеет такой же алфавит, как и у предъявленной ей машины. Отсюда вытекает необходимость наличия меток для указания положения исходной МТ. Такие метки удобно ставить вместо разделителя, стоящего непосредственно перед группой ячеек, содержащих код рассматриваемого символа. Поскольку первые пять цифр алфавита заняты под кодирование программы МТ, будем заменять разделитель перед символом, на котором остановилась исходная МТ, на цифру <em>6</em>.</p>

<p>Составление таблицы для одноленточной УМТ длительная и малопригодная для понимания в учебных целях процедура. Поэтому для наглядности построим трехленточную машину, которую всегда можно преобразовать в одноленточную по принципу, рассмотренному в Теореме 1.2(1). Ленты трехленточной универсальной машины Тьюринга будут иметь следующее назначение:</p>

<ul>
	<li>исходная лента, на которой записан код таблицы исходной МТ,</li>
	<li>рабочая лента, на ней записываются внутренние состояния исходной МТ,</li>
	<li>выходная лента &ndash; закодированная лента исходной МТ.</li>
</ul>

<p>В начале моделирования каждого такта работы исходной МТ, УМТ занимает на 3-ей ленте первую клетку. Эта клетка соответствует той клетке на ленте исходной МТ, которую в данный момент воспринимает считывающая головка исходной МТ.</p>

<p>УМТ движется по входной ленте, пока не дойдёт до команды, в которой внутреннее состояние совпадает с записью на 2-ой ленте, а воспринимаемый символ &ndash; с тем, который записан на входной ленте, в кодовой ячейке которой изображено положение исходной машины. Сравнение происходит по разрядам. В итоге УМТ находит на входной ленте нужную для исполнения команду МТ.</p>

<p>Очень важен механизм опознания того факта, что внутреннее состояние совпадает с записью на 2-ой ленте, а воспринимаемый символ &ndash; с тем, который записан на входной ленте. Любое запоминание прочитанных символов может производиться только путем изменения внутреннего состояния, однако при программировании УМТ количество состояний должно быть ограничено. В этой связи метод введения все новых и новых состояний типа S<sup>1</sup> S<sup>11</sup> S<sup>111</sup> S<sup>111</sup><sub>2</sub> S<sup>111</sup><sub>22</sub> S<sup>111</sup><sub>222</sub>S<sup>111</sup><sub>2222 </sub>&nbsp;&nbsp;и т.д. для запоминания количества &laquo;2&raquo; на второй ленте и &laquo;1&raquo; на третьей ленте является неосуществимым. Нам просто не хватит описательных возможностей для перебора всех допустимых состояний. Реально требуется механизм&nbsp; <strong><em>поразрядного</em></strong> сравнения. Способов естественно огромное множество.</p>

<p>По сути, на первой ленте нужно найти некий набор последовательностей &laquo;1&raquo; и &laquo;2&raquo;, идущих сразу после разделителя команд, который соответствует находящемуся на второй ленте коду состояния исходной машины (последовательность &laquo;2&raquo;) и обозреваемому на третьей ленте коду символа (последовательность &laquo;1&raquo;). Для оптимизации поэтапного сравнения возможно первоначально стоит проверять совпадение символа (т.е. двигать смотровые окошки на 1-ой и 3-ой ленте) и в случае удачи, продолжить сравнение, двигая окошки на 1-ой и 2-ой ленте.</p>

<p>Вероятны и другие способы поразрядного сравнения (например, копирование текущей конфигурации на 4-ую ленту и поиск соответствия её содержимому на 1-ой ленте), но важным остается сам факт: запоминать слово неопределенной длины целиком невозможно, в рамках наших возможностей только поразрядное сравнение содержимого лент.</p>

<p>Так или иначе, УМТ считывает инструкцию, соответствующую этой команде. Затем эта инструкция выполняется, при этом совершается три действия.</p>

<ul>
	<li>Изменяется положение исходной МТ<em>.</em> Например, если инструкция гласит &laquo;шаг вправо&raquo;, то на 3-ей ленте делается необходимое количество шагов вправо до ближайшего нового разделителя команд, который заменяется меткой текущего положения (вместо 4 ставится символ 6).&nbsp;</li>
	<li>Изменяется внутреннее состояние исходной МТ. На второй ленте вместо старого записывается ее новое состояние.</li>
	<li>Изменяется символ, содержащийся в рассматриваемой ячейке.&nbsp; Поскольку разные символы кодируются различным количеством единичек, то в случае замены символа необходимо предусмотреть процедуру сдвига (растягивание или сжимание слова на нужное число клеток).</li>
</ul>

<p>После этого моделируется следующий такт работы исходной МТ. Для этого снова анализируется содержание второй ленты (это теперь текущее состояние МТ) и символ, записанный справа от указателя текущего положения управляющей головки (специальная метка 6).&nbsp;</p>

<p>&nbsp;</p>


<p><strong><em>Глоссарий</em></strong></p>

<ul style="list-style-type:circle">
	<li>Машина В эквивалентна машине А, если в соответствующие такты их работы лента машины В содержит всю информацию о ленте машины А.</li>

<li><u>Теорема.</u>&nbsp;Всякая k -ленточная машина Тьюринга М может быть преобразована в эквивалентную машину М* с одной лентой.</li>

	<li>Самоанализирующие машины - это машины, в которых все служебные символы как-либо изображаются ленточными символами.</li>
	<li>Универсальная машина &ndash; машина Тьюринга, обладающая способностью путём подходящего кодирования выполнить любое вычисление.</li>
</ul>

<p>&nbsp;</p>


			</article>	</article>	</div></div>
@stop
@section('js-down')
		<!-- BEGIN JAVASCRIPT -->
    {!! HTML::script('js/libs/jquery/jquery-1.11.2.min.js') !!}
    {!! HTML::script('js/libs/jquery/jquery-migrate-1.2.1.min.js') !!}
    {!! HTML::script('js/libs/bootstrap/bootstrap.min.js') !!}
    {!! HTML::script('js/libs/spin.js/spin.min.js') !!}
    {!! HTML::script('js/libs/autosize/jquery.autosize.min.js') !!}
    {!! HTML::script('js/libs/nanoscroller/jquery.nanoscroller.min.js') !!}
    {!! HTML::script('js/core/source/App.js') !!}
    {!! HTML::script('js/core/source/AppNavigation.js') !!}
    {!! HTML::script('js/core/source/AppOffcanvas.js') !!}
    {!! HTML::script('js/core/source/AppCard.js') !!}
    {!! HTML::script('js/core/source/AppForm.js') !!}
    {!! HTML::script('js/core/source/AppNavSearch.js') !!}
    {!! HTML::script('js/core/source/AppVendor.js') !!}
    {!! HTML::script('js/core/demo/Demo.js') !!}
		<!-- END JAVASCRIPT -->
@stop
