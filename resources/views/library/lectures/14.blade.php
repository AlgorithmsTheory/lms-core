<!DOCTYPE html>
<html lang="en">
<head>
    <title>Лекция 14</title>

    <!-- BEGIN META -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="your,keywords">
    <meta name="description" content="Short explanation about this website">
    <!-- END META -->

    <!-- BEGIN STYLESHEETS -->
    {!! HTML::style('css/bootstrap.css') !!}
    {!! HTML::style('css/materialadmin.css') !!}
    {!! HTML::style('css/font-awesome.min.css') !!}
    {!! HTML::style('css/material-design-iconic-font.min.css') !!}
    <!-- END STYLESHEETS -->

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    {!! HTML::script('js/libs/utils/html5shiv.js') !!}
    {!! HTML::script('js/libs/utils/respond.min.js') !!}
    <![endif]-->


</head>
<body>
<section>

<div class="col-md-12 col-sm-6 card style-primary text-center">
    <h1 class="text-default-bright">Библиотека</h1>
</div>

<!-- BEGIN CONTENT-->
<div id="content">

    <!-- BEGIN BLANK SECTION -->
    <section>
        <div class="section-header">
            <ol class="breadcrumb">
                <li>{!! HTML::linkRoute('home', 'Главная') !!}</li>
                <li>{!! HTML::linkRoute('library_index', 'Библиотека') !!}</li>
                <li class="active">Лекция 14. Эффективная перечислимость и распознаваемость рекурсивных функций.</li>
            </ol>
        </div><!--end .section-header -->
        <div class="section-body">
        </div><!--end .section-body -->
    </section>
    <div class="card card-tiles style-default-light" style="margin-left:2%; margin-right:2%">
        <article class="style-default-bright">
            <div class="card-body">
                <article style="margin-left:10%; margin-right:10%; text-align: justify">
			
		

		

<h3>&sect; 14.1. Эффективная перечислимость рекурсивных функций</h3>

<p><strong><u>Т.14.1.(1)Теорема</u></strong></p>

<p><strong>Примитивно-рекурсивные функции эффективно перечислимы. </strong></p>

<p style="margin-left:36.0pt"><strong><u>Доказательство </u></strong></p>

<p>Из теоремы Клини следует, что примитивно-рекурсивные функции могут быть представлены в виде операторного терма, т.е. в виде схемы примитивной рекурсии, в которой используется всего несколько функциональных символов: для трех функций <em>C<sub>q</sub><sup>n</sup></em>, S (без индексов), U<sub>m</sub><sup>n</sup> и двух операций:&nbsp; S<sub>m</sub><sup>n</sup> с двумя индексами для подстановки и&nbsp; R<sup>n</sup> для примитивной рекурсии.</p>

<p>Построим доказательство эффективной перечислимости примитивно-рекурсивных функций на основе геделевой нумерации.</p>

<p>Для этого надо ввести кодовые номера для всех символов:</p>

<p style="margin-left:18.0pt">Введем такие номера</p>

<p style="margin-left:18.0pt">S (следование) &rarr; 1</p>

<p style="margin-left:18.0pt">C &rarr; 2</p>

<p style="margin-left:18.0pt">U &rarr; 3</p>

<p style="margin-left:18.0pt">S (подстановка) &rarr; 4</p>

<p style="margin-left:18.0pt">R (примитивная рекурсия) &rarr; 5</p>

<p style="margin-left:18.0pt">(&rarr; 6</p>

<p style="margin-left:18.0pt">) &rarr; 7</p>

<p style="margin-left:18.0pt">, &rarr; 8</p>

<p style="margin-left:18.0pt">x<sub>i</sub> &rarr; i+9 (здесь x<sub>i</sub> &ndash; номер переменной)</p>

<p>Возьмем ряд простых чисел: 2,3,5,7,&hellip;Дальнейшая процедура аналогична геделевой нумерации, например, алгоритмов Маркова.</p>

<p>Например,</p>

<p>x+y=R<sup>2</sup>[U<sub>1</sub><sup>1</sup>,S<sub>1</sub><sup>3</sup>(S,U<sub>1</sub><sup>3</sup>)]= 2<sup>5</sup>*3<sup>12</sup>*5<sup>6</sup>*7<sup>3</sup>*11<sup>10</sup>*13<sup>10</sup>*17<sup>8</sup>*&hellip;</p>

<p>Т.о. мы получили геделев номер примитивно-рекурсивного описания функции суммы двух аргументов. Геделевы номера &nbsp;эффективно распознаются среди натуральных чисел, следовательно их описания можно эффективно перечислить, а значит множество ПРФ &ndash; эффективно перечислимо, <strong>Q</strong><strong>.</strong><strong>E</strong><strong>.</strong><strong>D</strong><strong>.</strong></p>

<p><strong><u>Т.14.1.(2)Теорема</u></strong></p>

<p><strong>Множество частично-рекурсивных функций эффективно перечислимо. </strong></p>

<p style="margin-left:36.0pt"><strong><u>Доказательство </u></strong></p>

<p>&nbsp;Для наших целей важно, чтобы перечисление частично-рекурсивных функций было эффективным, т. е. чтобы у нас был эффективный способ нахождения <em>n</em>-й функции списка или хотя бы &nbsp;способ нахождения ее определения. Хотя это может показаться странным, но будет достаточно знать, что перечисление существует - нам даже не потребуется выяснять какие-либо подробности о его свойствах. Следовательно, вместо подробного доказательства, достаточно привести убедительный довод в пользу его возможности, т. е. что мы могли бы построить его, если бы это потребовалось.</p>

<p>Почему мы все же могли предположить, что существует эффективное перечисление частично-рекурсивных функций? В конце концов, они образуют фантастически богатое, причудливое и неупорядоченное множество объектов, <em>поскольку в это множество</em> <em>входят объекты, соответствующие всем возможным рекурсивным определениям.</em></p>

<p>На самом деле при ближайшем рассмотрении ясно, что определение каждой частично-рекурсивной функции состоит из конечного набора уравнений, каждое из&nbsp; которых включает конечное число символов, обозначающих <em>нуль,&nbsp; тождество, следование, примитивную рекурсию, суперпозицию&nbsp; и наименьшее число</em> в сочетании с конечным числом <em>запятых и скобок.</em> Точные правила их расположения не важны. Важно то, что в любой такой ситуации, всегда можно ввести некоторого рода бесконечное лексикографическое упорядочение составных объектов. Хотя эта ситуация кажется более сложной, есть способ сделать ее даже проще. Действительно, поскольку большинство частично-рекурсивных функций (или, скорее, определений) вовсе не определяет истинного окончания процесса вычислений, нам не надо слишком заботиться, чтобы при перечислении определений все последовательности символов были правильными. Действительно, мы можем рассмотреть какую-либо процедуру, которая, в конце концов, образует любую (и все) последовательности символов, требуемых для определений. Имеется только одна&nbsp; техническая проблема - остаться в рамках фиксированного алфавита. Она решается использованием, скажем, двоичного кодирования&nbsp;&nbsp; неограниченного числа названий переменных и функций, которые могут&nbsp; потребоваться. Тогда&nbsp; простая схема числового упорядочения будет эффективным перечисле&shy;нием при условии, что существует способ правильной интерпретации <em>n</em>-го описания.&nbsp;</p>

<p>Бесконечное лексикографическое упорядочение составных объектов легко нумеруется при помощи алгоритма Геделя. Из теоремы Клини&nbsp; следует, что частично-рекурсивные функции могут быть представлены в виде операторного терма, т.е. в виде схемы частичной рекурсии, в которой используется всего несколько функциональных символов: для трех функций <em>C<sub>q</sub><sup>n</sup></em>, S (без индексов), U<sub>m</sub><sup>n</sup> и трех операций:&nbsp; S<sub>m</sub><sup>n</sup> с двумя индексами для подстановки, R<sup>n</sup> для примитивной рекурсии и &mu; для минимизации. Учитывая этот факт, снимается вопрос о правильной интерпретации <em>n</em>-го описания: если кодировать будем не системы уравнений, а схемы частично-примитивных рекурсий в виде операторных термов, то такая интерпретация будет автоматической.</p>

<p>Построим доказательство эффективной перечислимости на основе геделевой нумерации. Для этого надо ввести кодовые номера для всех элементов при помощи геделевой нумерации.</p>

<p style="margin-left:18.0pt">Введем такие номера</p>

<p style="margin-left:18.0pt">S (следование) &rarr; 1</p>

<p style="margin-left:18.0pt">C (константа) &rarr; 2</p>

<p style="margin-left:18.0pt">U (тождества) &rarr; 3</p>

<p style="margin-left:18.0pt">S (подстановка) &rarr; 4</p>

<p style="margin-left:18.0pt">R (примитивная рекурсия) &rarr; 5</p>

<p style="margin-left:18.0pt">&Mu; (минимизация) &nbsp;&rarr; 6</p>

<p style="margin-left:18.0pt">(&rarr; 7</p>

<p style="margin-left:18.0pt">) &rarr; 8</p>

<p style="margin-left:18.0pt">, &rarr; 9</p>

<p style="margin-left:18.0pt">x<sub>i</sub> &rarr; i+10</p>

<p>Возьмем ряд простых чисел: 2,3,5,7,&hellip;Дальнейшая процедура аналогична геделевой нумерации примитивно-рекурсивных функций. Т.о. мы получили геделев номер частично-рекурсивного описания. Геделевы номера эффективно распознаются среди натуральных чисел, следовательно, частично-рекурсивные функции можно эффективно перечислить, <strong>Q</strong><strong>.</strong><strong>E</strong><strong>.</strong><strong>D</strong><strong>.</strong></p>

<p><u>Предостережение</u>: не делайте никаких далеко идущих предположений!&nbsp; Некоторые функции <em>f<sub>n</sub></em><em>(</em><em>x</em><em>)</em> не могут быть определены даже хотя бы для одного значения <em>x.</em> Некото&shy;рые функции с разными индексами, например&nbsp;&nbsp;&nbsp;&nbsp; <em>f<sub>i</sub></em><em> (</em><em>x</em><em>)</em> и <em>f<sub>j</sub></em><em> (</em><em>x</em><em>)</em>, могут быть одинаковыми: <em>f<sub>i</sub></em><em>(</em><em>x</em><em>) = </em><em>f<sub>j</sub></em><em>(</em><em>x</em><em>)</em> для всех <em>x. </em>Действительно, некоторые функции могут появляться в списке бесконечно часто, что соответствует совершенно разным определениям. Един&shy;ственное,&nbsp; в чем мы уверены, это то, что если функция частично-рекурсивна, то она имеет <em>по крайней мере</em> один индекс в пере&shy;числении.</p>

<p><strong><u>Т.14.1.(3)Теорема</u></strong></p>

<p><strong>Общерекурсивные функции не поддаются эффективному перечислению.</strong></p>

<p><em>На уровне тезисов:</em></p>

<p>Из тезиса Чёрча: всякая арифметическая функция, вычислимая в обычном смысле (ВАФ), есть обще рекурсивная функция (ОРФ), а всякая &nbsp;частичная арифметическая функция, вычислимая в обычном смысле (ЧВАФ), есть частично рекурсивная функция (ЧРФ). Известно (на основании теоремы Тьюринга), что ВАФ эффективно не перечислимы. Отсюда следует, что и ОРФ эффективно не перечислимы.</p>

<p style="margin-left:36.0pt"><strong><u>Доказательство</u></strong></p>

<p>Допустим, что множество общерекурсивных функций n-переменных эффективно перечислимо.</p>

<p>Тогда существует алгоритм, по которому их можно перечислить. Применим этот алгоритм. Получим последовательность:</p>

<p><em>f</em><em><sub>0</sub></em><em>(</em><em>x</em><em><sub>1</sub></em><em>,&hellip;,</em><em>x<sub>n</sub></em><em>), </em><em>f</em><em><sub>1</sub></em><em>(</em><em>x</em><em><sub>1</sub></em><em>,&hellip;,</em><em>x<sub>n</sub></em><em>),.. </em><em>f<sub>n</sub></em><em>(</em><em>x</em><em><sub>1</sub></em><em>,&hellip;,</em><em>x<sub>n</sub></em><em>),..</em></p>

<p>Построим диагональную функцию:</p>

{!! HTML::image('img/library/Pic/14.1.JPG') !!}

<p>Укажем процедуру вычисления <em>g</em>. Для любых значений <em>x,y,z</em> мы можем сначала провести операцию сравнения, и затем, если <em>x=y=z</em>, отыскать функцию <em>f</em><em><sub>x</sub></em><em>.</em> Это вполне рекурсивная операция (сравнение аргументов). Если результат сравнения отрицательный (ложь), значение функции <em>g</em><em>(x<sub>1</sub>,&hellip;,x<sub>n</sub>)=0.</em> Если результат сравнения положительный (истина), далее можем применить к ней алгоритм вычисления функции <em>f</em><em><sub>x</sub></em><em>(x,x,x)</em> в заданной точке. Такой алгоритм существует в силу рекурсивности функций вида <em>f</em><em><sub>i</sub></em><em>(x<sub>1</sub>,&hellip;,x<sub>n</sub>).</em> Прибавление к результату вычисления единички есть тривиальная рекурсивная функция. Т.о. видно, что эта диагональная функция будет тоже общерекурсивной.</p>

<p>Раз построенная функция принадлежит к множеству общерекурсивных функций, то она должна быть среди ранее эффективно перечисленных функций, но по построению она не может быть среди них, так как от каждой функции она отличается хотя бы в одной точке. Получили противоречие, следовательно, общерекурсивные функции нельзя эффективно перечислить,<strong>Q</strong><strong>.</strong><strong>E</strong><strong>.</strong><strong>D</strong></p>

<h3>&sect; 14.2. Эффективная распознаваемость рекурсивных функций</h3>

<p><strong><u>Т.14.2.(1)Теорема</u></strong></p>

<p><strong>Примитивно-рекурсивные функции не поддаются&nbsp; эффективному распознаванию среди общерекурсивных функций</strong>.</p>

<p style="margin-left:36.0pt"><strong><u>Доказательство&nbsp;</u></strong></p>

<p>Возьмем общерекурсивную, но не примитивно-рекурсивную функцию <em>f(x).</em> Построим&nbsp; <em>g(x)</em> следующим образом:</p>

{!! HTML::image('img/library/Pic/14.2.JPG') !!}

<p>Функция <em>g(x)</em> тоже общерекурсивна (в силу того, что она везде определена и вычислима). Но на самом деле, если <strong><em>Т</em></strong> все-таки остановится, то <em>g(x) </em>будет являться также примитивно-рекурсивной (потому что функция, отличная от нуля в конечном числе точек всегда примитивно-рекурсивна). Пусть мы умеем (знаем какой-то алгоритм) распознавать примитивно-рекурсивные функции&nbsp; среди общерекурсивных функций. Применим этот алгоритм к общерекурсивной функции <em>g(x).</em> Если удастся сказать, является ли она примитивно-рекурсивной, значит, окажется решенной и задача об остановке машины Тьюринга, что противоречит ранее доказанной теореме.</p>

<p>Значит наше предположение не верно, следовательно, примитивно рекурсивные функции не поддаются эффективному распознаванию среди всех общерекурсивных функций, <strong>Q</strong><strong>.</strong><strong>E</strong><strong>.</strong><strong>D</strong><strong>.</strong></p>

<p><strong><u>Т.14.2.(2)Теорема</u></strong></p>

<p><strong>Общерекурсивные функции не поддаются&nbsp; эффективному распознаванию среди частично рекурсивных функций. </strong></p>

<p><em>На уровне тезисов:</em></p>

<p>Понятие общерекурсивных функций совпадает с ВАФ, а понятие частично рекурсивной функции совпадает с ВЧАФ. А так как ВАФ не распознается среди ВЧАФ, то общерекурсивные функции не поддаются эффективному распознаванию среди частично рекурсивных функций.</p>

<p style="margin-left:36.0pt"><strong><u>Доказательство </u></strong></p>

<p>Множество частично рекурсивных функций &ndash; эффективно перечислимо, а значит к нему и к его подмножеству, соответствующему классу общерекурсивных функций, можно применить теорему Поста<strong>. </strong>Предположим противное, а именно, что рекурсивные функции поддаются&nbsp; эффективному распознаванию среди частично рекурсивных функций. Это означает, что возможно также эффективно перечислить как общерекурсивные функции, так и частично рекурсивные, но не общерекурсивные функции. Насчет второго ничего неизвестно, а вот первое явно противоречит доказанной ранее теореме 4.8.(3). &nbsp;Следовательно, общерекурсивные функции не распознаваемы эффективно среди частично рекурсивных функций, <strong>Q</strong><strong>.</strong><strong>E</strong><strong>.</strong><strong>D</strong><strong>.</strong></p>

			</article></article>	</div></div>

    <!-- BEGIN JAVASCRIPT -->
    {!! HTML::script('js/libs/jquery/jquery-1.11.2.min.js') !!}
    {!! HTML::script('js/libs/jquery/jquery-migrate-1.2.1.min.js') !!}
    {!! HTML::script('js/libs/bootstrap/bootstrap.min.js') !!}
    {!! HTML::script('js/libs/spin.js/spin.min.js') !!}
    {!! HTML::script('js/libs/autosize/jquery.autosize.min.js') !!}
    {!! HTML::script('js/libs/nanoscroller/jquery.nanoscroller.min.js') !!}
    {!! HTML::script('js/core/source/App.js') !!}
    {!! HTML::script('js/core/source/AppNavigation.js') !!}
    {!! HTML::script('js/core/source/AppOffcanvas.js') !!}
    {!! HTML::script('js/core/source/AppCard.js') !!}
    {!! HTML::script('js/core/source/AppForm.js') !!}
    {!! HTML::script('js/core/source/AppNavSearch.js') !!}
    {!! HTML::script('js/core/source/AppVendor.js') !!}
    {!! HTML::script('js/core/demo/Demo.js') !!}
    <!-- END JAVASCRIPT -->
</section>
</body>
</html>