<!DOCTYPE html>
<html lang="en">
<head>
    <title>Лекция 15</title>

    <!-- BEGIN META -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="your,keywords">
    <meta name="description" content="Short explanation about this website">
    <!-- END META -->

    <!-- BEGIN STYLESHEETS -->
    {!! HTML::style('css/bootstrap.css') !!}
    {!! HTML::style('css/materialadmin.css') !!}
    {!! HTML::style('css/font-awesome.min.css') !!}
    {!! HTML::style('css/material-design-iconic-font.min.css') !!}
    <!-- END STYLESHEETS -->

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    {!! HTML::script('js/libs/utils/html5shiv.js') !!}
    {!! HTML::script('js/libs/utils/respond.min.js') !!}
    <![endif]-->


</head>
<body>
<section>

<div class="col-md-12 col-sm-6 card style-primary text-center">
    <h1 class="text-default-bright">Библиотека</h1>
</div>

<!-- BEGIN CONTENT-->
<div id="content">

    <!-- BEGIN BLANK SECTION -->
    <section>
        <div class="section-header">
            <ol class="breadcrumb">
                <li>{!! HTML::linkRoute('home', 'Главная') !!}</li>
                <li>{!! HTML::linkRoute('library_index', 'Библиотека') !!}</li>
                <li class="active">Лекция 15.</li>
            </ol>
        </div><!--end .section-header -->
        <div class="section-body">
        </div><!--end .section-body -->
    </section>
    <div class="card card-tiles style-default-light" style="margin-left:2%; margin-right:2%">
        <article class="style-default-bright">
            <div class="card-body">
                <article style="margin-left:10%; margin-right:10%; text-align: justify">
			


<h3>&sect; 4.4.1 Нерекурсивные функции</h3>

<p style="margin-left:36.0pt"><strong><em><a name="150">Нерекурсивной</a></em></strong><em>&nbsp; называется функция, значение которой нельзя вычислить, несмотря на то, что в&nbsp; данной рассматриваемой точке сама функция определена</em>.</p>

<p>Например, зададим функцию <em>f</em><em>(</em><em>x</em><em>)</em> следующим образом</p>

{!! HTML::image('img/library/Pic/15.1.JPG') !!}

<p style="margin-left:35.4pt">Значения функции везде определены (0 или 1), но вычислены быть не могут, иначе это означало бы, что решена задача об остановке произвольной машины Тьюринга на чистой ленте, что противоречит теореме 1.5.(2).</p>

<h3>&sect; 4.4.2 Непримитивно рекурсивные функции</h3>

<p style="margin-left:36.0pt"><strong><em><a name="131">Непримитивно рекурсивной</a></em></strong><em>&nbsp; называется функция, являющаяся общерекурсивной, но не принадлежащая множеству примитивно-рекурсивных функций</em>.</p>

<p>Одним из методов решения задачи о нахождении непримитивно рекурсивных функций может служить метод построения функции, растущей быстрее любой функции заданного класса. Этот метод очень удобен при исследовании сравнительной силы различного рода рекурсий. Изложим его применительно к уже рассмотренному классу примитивно рекурсивных функций.</p>

<p>Итак, нужно найти по возможности простые, но очень быстрорастущие функции. Опыт показывает, что произведение растет быстрее суммы, степень быстрее произведения. Называя сложение, умножение и возведение в степень действиями 0-й, 1-й и 2-й ступени и вводя для них в целях единообразия обозначения:</p>

<p><em>P</em><em><sub>0 </sub></em><em>(</em><em>a</em><em>, </em><em>x</em><em>)=</em><em>a</em><em>+</em><em>x</em><em>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em><em>P</em><em><sub>1 </sub></em><em>(</em><em>a</em><em>, </em><em>x</em><em>)=</em><em>a</em><em>∙</em><em>x</em><em>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em><em>P</em><em><sub>2</sub></em><em>(</em><em>a</em><em>, </em><em>x</em><em>)=</em><em>a<sup>x</sup></em><em>,&nbsp;&nbsp; </em></p>

<p>приходим к знакомой всем идее о продолжении этой последовательности путем введения действий высших ступеней. При этом действие высшей ступени должно возникать из действия предыдущей ступени так же, как умножение возникает из сложения, а возведение в степень из умножения. Функции <em>Р<sub>0</sub>, Р<sub>1</sub>, Р<sub>2</sub></em> &nbsp;связаны следующими соотношениями:</p>

<p><em>P</em><em><sub>1</sub></em><em>(</em><em>a</em><em>, </em><em>x</em><em>+1)=</em><em>P</em><em><sub>0</sub></em><em>(</em><em>a</em><em>, </em><em>P</em><em><sub>1</sub></em><em>(</em><em>a</em><em>, </em><em>x</em><em>)),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em><em>P</em><em><sub>1</sub></em><em>(</em><em>a</em><em>, 1)=</em><em>a</em><em>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em></p>

<p><em>P</em><em><sub>2</sub></em><em>(</em><em>a</em><em>, </em><em>x</em><em>+1)=</em><em>P</em><em><sub>1</sub></em><em>(</em><em>a</em><em>, </em><em>P</em><em><sub>2</sub></em><em>(</em><em>a</em><em>, </em><em>x</em><em>)),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em><em>P</em><em><sub>2</sub></em><em>(</em><em>a</em><em>, 1)=</em><em>a</em><em>.</em></p>

<p>Продолжим эту цепочку, полагая по определению для <em>n</em><em>=2, 3,&hellip;</em></p>

<p><em>P<sub>n</sub></em><em><sub>+1</sub></em><em>(</em><em>a</em><em>, 1)=</em><em>a</em><em>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em></p>

<p><em>P<sub>n</sub></em><em><sub>+1</sub></em><em>(</em><em>a</em><em>, </em><em>x</em><em>+1)=</em><em>P<sub>n</sub></em><em>(</em><em>a</em><em>, </em><em>P<sub>n</sub></em><em><sub>+1</sub></em><em>(</em><em>a</em><em>, </em><em>x</em><em>)).</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>Чтобы функции <em>P<sub>n</sub></em><em>(</em><em>a</em><em>, </em><em>x</em><em>)</em> были определены всюду, положим&nbsp; <em>P<sub>n</sub></em><em><sub>+1</sub></em><em>(</em><em>a</em><em>, 0)=1 </em>при <em>n</em><em>=1, 2,&hellip;</em> и указанные соотношения будем считать определениями функций&nbsp; <em>P<sub>n</sub></em><em>(</em><em>a</em><em>, </em><em>x</em><em>)</em> для <em>n</em><em>=2, 3,&hellip;</em> Ясно, что необходимо добавить соотношение <em>P</em><em><sub>1</sub></em><em>(</em><em>a</em><em>,0)=0.</em> Тогда, например,</p>

<p><em>P</em><em><sub>3</sub></em><em>(</em><em>a</em><em>, 0)=1,&nbsp;&nbsp;&nbsp; </em><em>P</em><em><sub>3</sub></em><em>(</em><em>a</em><em>, 1)=</em><em>a</em><em>,&nbsp;&nbsp;&nbsp; </em><em>P</em><em><sub>3</sub></em><em>(</em><em>a</em><em>, 2)=</em><em>a<sup>a</sup></em><em>,&nbsp;&nbsp;&nbsp; </em><em>P</em><em><sub>3</sub></em><em>(</em><em>a</em><em>, 3)=(</em><em>a<sup>a</sup></em><em>)</em><em><sup>a</sup></em><em>.</em></p>

<p>Введем новые функции&nbsp;&nbsp;&nbsp; <em>B</em><em>(</em><em>n</em><em>, </em><em>x</em><em>)=</em><em>P<sub>n</sub></em><em>(2,</em><em>x</em><em>),&nbsp;&nbsp; </em><em>A</em><em>(</em><em>x</em><em>)=</em><em>B</em><em>(</em><em>x</em><em>, </em><em>x</em><em>).</em></p>

<p>Для функции <em>B</em><em>(</em><em>n</em><em>, </em><em>x</em><em>)</em> из указанных соотношений вытекают следующие тождества:</p>

{!! HTML::image('img/library/Pic/15.2.JPG') !!}

<p>возникновения рекурсивной функции&nbsp; <em>B</em><em>(</em><em>n</em><em>,</em><em>x</em><em>) </em>из примитивно рекурсивных функций называется <strong><em>рекурсией второй ступени.</em></strong></p>

<p>Можно определить функцию с подобными свойствами иначе, не прибегая к аналогии с возрастанием порядка операций от сложения к умножению, от умножения к степени и далее. Например, классическая <em>функция Аккермана</em>&nbsp;&mdash; относительно простой пример вычислимой функции, которая не является примитивно рекурсивной. Она принимает два неотрицательных целых числа в качестве параметров и в качестве своего значения возвращает натуральное число.</p>

<p>Функция Аккермана определяется рекурсивно для неотрицательных целых чисел <em>m</em> и <em>n</em> следующим образом:</p>

{!! HTML::image('img/library/Pic/15.3.JPG') !!}

<p>Может показаться неочевидным, что рекурсия всегда заканчивается. Это следует из того, что при рекурсивном вызове или уменьшается значение <em>m</em>, или значение <em>m</em> сохраняется, но уменьшается значение <em>n</em>. Это означает, что каждый раз пара (<em>m</em>, <em>n</em>) уменьшается с точки зрения лексикографического порядка, значит, значение <em>m</em> в итоге достигнет нуля. Для одного значения <em>m</em> существует конечное число возможных значений <em>n</em> (так как первый вызов с данным <em>m</em> был произведён с каким-то определённым значением <em>n</em>, а в дальнейшем, если значение <em>m</em> сохраняется, значение <em>n</em> может только уменьшаться), а количество возможных значений <em>m</em>, в свою очередь, тоже конечно. Однако, при уменьшении <em>m</em> значение, на которое увеличивается <em>n</em>, обычно очень велико. Для того, чтобы почувствовать это, необходимо просто начать вычисление.</p>

<p>Внимательный читатель без проблем за несколько минут вычислит значение функции Аккермана в точке (2, 2), а потратив еще немного времени с использованием только карандаша и бумаги получит значение функции в точке (3, 3).</p>

<p>Интересно проследить рост значений этой функции, например, зафиксировав значение <em>n</em>=4.</p>

<p><em>А</em> (0, 4) = 4+1 = 5</p>

<p><em>А</em> (1, 4) =<em> А</em> (0, <em>А</em> (1, 3)) =</p>

<p style="margin-left:35.4pt"><em>=А</em> (0, <em>А</em> (0, <em>А</em> (1,2))) =</p>

<p style="margin-left:35.4pt"><em>=А</em> (0, <em>А</em> (0, <em>А</em> (0, <em>А</em> (1, 1)))) =</p>

<p style="margin-left:35.4pt"><em>=А</em> (0, <em>А</em> (0, <em>А</em> (0, <em>А</em> (0, <em>А</em> (1, 0))))) =</p>

<p style="margin-left:35.4pt"><em>=А</em> (0, <em>А</em> (0, <em>А</em> (0, <em>А</em> (0, <em>А</em> (0, 1))))) =</p>

<p style="margin-left:35.4pt"><em>=А</em> (0, <em>А</em> (0, <em>А</em> (0, <em>А</em> (0, 2)))) =</p>

<p style="margin-left:35.4pt"><em>=А</em> (0, <em>А</em> (0, <em>А</em> (0, 3))) =</p>

<p style="margin-left:35.4pt"><em>=А</em> (0, <em>А</em> (0, 4)) =</p>

<p style="margin-left:35.4pt"><em>=А</em> (0, 5) = 6</p>

<p><em>А</em> (2, 4)= <em>А</em> (1, <em>А</em> (2, 3)) =</p>

<p style="margin-left:35.4pt">= <em>А</em> (1, <em>А</em> (1, <em>А</em> (2, 2))) =</p>

<p style="margin-left:35.4pt">= <em>А</em> (1, <em>А</em> (1, <em>А</em> (1, <em>А</em> (2, 1)))) =</p>

<p style="margin-left:35.4pt">= <em>А</em> (1, <em>А</em> (1, <em>А</em> (1, <em>А</em> (1, <em>А</em> (2, 0))))) =</p>

<p style="margin-left:35.4pt">= <em>А</em> (1, <em>А</em> (1, <em>А</em> (1, <em>А</em> (1, <em>А</em> (1, 1))))) =</p>

<p style="margin-left:35.4pt">&hellip;(здесь для ускорения процесса&nbsp; использованы предыдущие результаты, например, тот факт что <em>А</em> (1, 1) =3)&hellip;</p>

<p style="margin-left:35.4pt">= <em>А</em> (1, <em>А</em> (1, <em>А</em> (1, <em>А</em> (1, <strong>3</strong>)))) =</p>

<p style="margin-left:35.4pt">= <em>А</em> (1, <em>А</em> (1, <em>А</em> (1, <strong>5</strong>))) =</p>

<p style="margin-left:35.4pt">=продолжив далее, получим в итоге, что <em>А</em> (2, 4)=11</p>

<p>Аналогично можно вручную вычислить (это будет не очень быстро, но вполне реально)</p>

<p><em>А</em> (3, 4)=125</p>

<p>Но дальше уже возникают сложности. С формальной точки зрения значение функции Аккермана всегда вычислимо &ndash; есть строгий, точный алгоритм, заканчивающийся за конечное число шагов. &nbsp;Однако получить численное значение в точке (4, 4) обычным способом вряд удастся. Эта функция растёт очень &ndash; очень быстро.</p>

<p>Аналитически можно выразить число <em>А</em> (4, 4) через степени числа 2:</p>

{!! HTML::image('img/library/Pic/15.4.jpg') !!}

<p>Однако практически это вряд ли имеет смысл: это число настолько велико, что количество цифр в его порядке многократно превосходит количество атомов в наблюдаемой части вселенной. Задумайтесь над этим фактом и попробуйте представить, чему равно <em>А</em> (100, 4):</p>

<h3>&sect; 4.4.3.&nbsp; Границы применимости формальных моделей алгоритмов (факультативный блок, в материал экзамена не входит)</h3>

<p>Как показано в этой книге, машина Тьюринга, машина Поста, нормальные алгоритмы Маркова, рекурсивные функции являются разновидностями формализации понятий &quot;вычисление&quot; и &quot;алгоритм&quot;. Все эти формализации эквивалентны друг другу, т.е. существуют стандартные алгоритмы, позволяющие программу для машины Тьюринга перевести в нормальный алгоритм или программу для машины Поста и т.д., и также возможен и обратный перевод. Любая функция, вычислимая по Тьюрингу, вычислима также посредством машины Поста, нормальных алгоритмов или рекурсивных функций.</p>

<p>Отсюда можно сделать вывод, что существует (потенциально бесконечный) класс &quot;универсальных вычислительных машин&quot;, способных (в силу того, что каждая из них является адекватной формализацией понятия алгоритма) вычислить любую функцию, вычислимую в интуитивном смысле. Т.е. любая формализация алгоритма, принадлежащая к данному классу, позволяет адекватно представить любой вычислительный процесс (при условии, что этот процесс может быть представлен в виде ясной, четкой, однозначной инструкции, написанной, например, на естественном языке - т.е. если этот процесс можно представить как &quot;алгоритмический&quot; в интуитивном смысле этого слова). Утверждение о существовании класса универсальных вычислительных машин, способных вычислить все, что вычислимо в интуитивном смысле, известно как &quot;тезис Черча&quot;.</p>

<p>Тезис Черча нередко рассматривают как важный аргумент в пользу возможности искусственного интеллекта. Действительно, из тезиса Черча вытекает, что все универсальные вычислительные устройства качественно эквивалентны друг другу. Иными словами, одна универсальная вычислительная машина не может быть качественно &quot;умнее&quot; другой - в том смысле, что задачи, принципиально неразрешимые для машины одного типа, будут также неразрешимыми и для машин любых других типов. Различия между универсальными вычислительными машинами могут касаться лишь количественных параметров, а именно, они могут отличаться лишь по скорости вычислений и по объему памяти.</p>

<p>Однако эти тезисы бесспорно применимы при сравнении искусственных вычислительных машин. Когда речь заходит о нашем мозге, сознании или в глобальном смысле человеческих способностях, ситуация в корне меняется. Помимо философских аспектов в пользу доводов о возможности или невозможности создания интеллектуальных систем, сопоставимых с человеческим потенциалом, появляются и строго формалистические доводы на основании принятой аксиоматики.</p>

<p>Предположим, что математические способности некоторого математика, назовем его Человек_Разумный&nbsp; полностью описываются некоторой формальной системой F. Это означает, что любое математическое утверждение, которое Человек_Разумный признает &quot;неоспоримо верным&quot;, является теоремой, доказываемой в F, и наоборот. Предположим, также, что Человек_Разумный знает, что F описывает его математические способности. Человек_Разумный, также, полагает, что тот факт, что F описывает его математические способности, эквивалентен вере в непротиворечивость и непогрешимость F (в противном случае мы должны были бы поставить под сомнение истины, которые представляются нам &quot;неоспоримо истинными&quot;).</p>

<p>Согласно теореме Геделя о неполноте формальных систем, поскольку F непротиворечива, существует геделевское предложение G(F), которое должно быть истинным, но которое не является теоремой в системе F. Однако, поскольку Человек_Разумный верит, что F - непротиворечивая система и знает, что F представляет его способность к математическим рассуждениям, он должен прийти к выводу, что G(F) является &quot;неоспоримой истиной&quot;. Таким образом, мы получаем математическое утверждение G(F), которое Человек_Разумный признает истинным, но которое не является теоремой в F, что противоречит первоначальному предположению, что F представляет целиком и полностью математические способности Человека_Разумного.</p>

<p>Отсюда вывод, что никакая формальная система не может быть адекватным выражением математических способностей человека и, следовательно, невозможна полная компьютерная имитация человеческого сознания.</p>

<p>Однако эта точка зрения не является бесспорной и у неё довольно много авторитетных противников. Заинтересованный читатель может продолжить изучение этой темы в&nbsp; рамках физиологии мозга, философии бытия, молекулярной физики, квантовой механики и других направлений современных исследований, которые ставят своей целью ответ на простейший по своей формулировке вопрос А.Тьюринга: &laquo;А может ли машина МЫСЛИТЬ?&raquo;.</p>


			</article></article>	</div></div>

    <!-- BEGIN JAVASCRIPT -->
    {!! HTML::script('js/libs/jquery/jquery-1.11.2.min.js') !!}
    {!! HTML::script('js/libs/jquery/jquery-migrate-1.2.1.min.js') !!}
    {!! HTML::script('js/libs/bootstrap/bootstrap.min.js') !!}
    {!! HTML::script('js/libs/spin.js/spin.min.js') !!}
    {!! HTML::script('js/libs/autosize/jquery.autosize.min.js') !!}
    {!! HTML::script('js/libs/nanoscroller/jquery.nanoscroller.min.js') !!}
    {!! HTML::script('js/core/source/App.js') !!}
    {!! HTML::script('js/core/source/AppNavigation.js') !!}
    {!! HTML::script('js/core/source/AppOffcanvas.js') !!}
    {!! HTML::script('js/core/source/AppCard.js') !!}
    {!! HTML::script('js/core/source/AppForm.js') !!}
    {!! HTML::script('js/core/source/AppNavSearch.js') !!}
    {!! HTML::script('js/core/source/AppVendor.js') !!}
    {!! HTML::script('js/core/demo/Demo.js') !!}
    <!-- END JAVASCRIPT -->
</section>
</body>
</html>